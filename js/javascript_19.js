/*
  # 문제
  소수 찾기

  # 문제 설명
  1부터 입력받은 숫자 n 사이에 있는 소수의 개수를 반환하는 함수, solution을 만들어 보세요.

  소수는 1과 자기 자신으로만 나누어지는 수를 의미합니다.
  (1은 소수가 아닙니다.)

  # 제한 조건
  n은 2이상 1000000이하의 자연수입니다.

  # 입출력 예
  n	result
  10	4
  5	3

  # 입출력 예 설명
  입출력 예 #1
  1부터 10 사이의 소수는 [2,3,5,7] 4개가 존재하므로 4를 반환

  입출력 예 #2
  1부터 5 사이의 소수는 [2,3,5] 3개가 존재하므로 3를 반환
*/

const test01 = (n) => {
  const result = [...Array(n)].map((elem, index) => index + 1);

  const resultfilter = result.filter((el) => {
    const len = [1];

    for (let i = 2; i <= el; i++) {
      if (el % i) continue;
      len.push(el);
    }

    return len.length === 2;
  });

  return resultfilter.length;
};

console.log(test01(10)); // 4

/*
  # 문제풀이 - test01
  1. result 변수를 생성하여 파라미터로 받은 값을 순서대로 배열에 담는다. 이 때 Array 생성자를 이용하여 빈 배열에 undefined값을 할당하고
  map메서드를 활용하여 undefined에 index를 넣어주는데 index는 0부터 시작하므로 시작 값을 1부터 시작하기 위해 1을 더해준다.
  2. 변수에 나열한 각 요소를 filler메서드를 통해 문제 조건에 따라 필터 처리 해준다. len이라는 변수를 생성하여 배열에 1이라는 요소를 할당해준다.
  1를 할당하는 이유는 소수를 구하기 위해 반복문을 돌릴 때 1은 무조건 포함되는 값이기 때문에 1을 미리 넣어준 후 그 이후에 값부터 반복문을 돌리기 위해서이다.
  3. 반복문을 돌리는데 이 때 1은 이미 배열에 담겨있기 때문에 초기값은 2로 설정한다. 그 후 현재 map메서드 콜백 함수가 실행되고 있는 요소를 i로 나누어
  나머지를 조건으로 설정하고 0이 아닌 경우 소수가 아니기 때문에 continue를 통해 다음 사이클의 반복문을 실행한다. 또한 소수가 맞는 경우 생성해놓은 배열
  len에 이 요소의 값을 push메서드로 추가해준다.
  4. filter 메서드의 비교값을 출력하는데 소수는 1과 자기 자신만으로 이루어져있기 때문에 len배열 요소 길이가 2인지 판단하여 필터 처리한다.
  5. 최종적으로 필터 처리된 요소의 길이 값을 반환한다.
*/
