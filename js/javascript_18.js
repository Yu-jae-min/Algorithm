/*
    # 문제
    수박수박수박수박수박수?

    # 문제 설명
    길이가 n이고, "수박수박수박수...."와 같은 패턴을 유지하는 문자열을 리턴하는 함수, solution을 완성하세요.
    예를들어 n이 4이면 "수박수박"을 리턴하고 3이라면 "수박수"를 리턴하면 됩니다.

    # 제한 조건
    n은 길이 10,000이하인 자연수입니다.

    # 입출력 예
    n	    return
    3	    "수박수"
    4	    "수박수박"
*/

const test01 = (n, t = "", i = 0) => {
  return i < n
    ? i % 2 === 0
      ? test01(n, (t += "수"), (i += 1))
      : test01(n, (t += "박"), (i += 1))
    : t;
};

console.log(test01(3)); // 수박수

/*
        # 문제풀이 - test01
        1. 파라미터에 문자를 받을 파라미터와, 카운팅 할 i를 생성한다.
        2. 삼항연산자를 중첩 활용하는데 이 때 i가 n보다 작은 경우를 비교하여 i가 큰 경우는 쌓아놓은 문자 t를 반환하고 아닌 경우 재귀함수를 호출한다.
        3. 재귀함수 호출 시에도 삼항연산자를 활용하는데 i가 짝수인 경우 수, i가 홀수인 경우 박을 t에 담아 호출한다. 또한 i의 값을 1씩 더한다.
        -> 프로그래머스에서 테스트 코드 한 개에서 런타임 에러가 발생하였다.
*/

const test02 = (n) => {
  return "수박".repeat(n / 2 + 1).substring(0, n);
};

console.log(test02(3)); // 수박수

/*
        # 문제풀이 - test02
        1. '수박' 문자를 repeat 메소드로 반복시키는데 반복시키는 값은 n을 2로 나눈 값에 1을 더한 만큼 반복시킨다. 왜냐하면 n 파라미터에 따라
        문자가 추가될 때 수 혹은 박과 같이 한 글자씩 추가되기 때문에 만약 n만큼 반복시키면 출력해야하는 값에 2배나 되는 양만큼 반복시켜놓는 것과 같기 때문이다.
        또한 1을 더하는 이유는 나누어지는 값이 정수가 아닌 경우 때문에 여유 값을 주기 위해 1을 더해주는 것이다.
        2. 반복시킨 문자를 substring메소드로 자르는데 0부터 n까지 잘라 출력한다.
*/

/*
        # 문제풀이 비교
        함수 실행 속도 : test02 > test01
        재귀를 활용해서 푼 첫번째 풀이보다 메소드를 두번 사용한 두번째 풀이가 더 좋은 풀이였다.
        함수 실행 속도도 빨랐고 가독성, 코드의 양도 더 좋았다. 첫번째 풀이에서는 반복되는 문자를 절차적으로 쌓아가는 방식으로 생각했는데
        두번째 풀이에서는 쌓아놓은 문자를 잘라내는 형식으로 작성되었다. 이렇게 여러가지 방식으로 생각하는 것에 더욱 익숙해져야겠다.
*/
